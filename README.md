
# Quasi DI

A tiny, elegant dependency injection library for golang.

## To The Point

### Importing

```go
import "github.com/quasi-go/di"
```

### Example Types

Here are the types from our example:

```go
type A struct {
	Name string
}

type B struct {
	Type       string
	PtrDep     *A
	ValueDep   A
	privateDep *A
}

type C struct {
	B
}

type I interface {} // A, B & C all implement I
```

### BindInstance

`BindInstance[T](inst)` bind type `T` to the passed `inst`.

```go
a := &A{Name: "Alice"}
di.BindInstance[A](a)
```

### Instance

`di.Instance[A]()` retrieves the same instance `a` from above

```go
resolvedA1 := di.Instance[A]()
```

- `resolvedA` is a `*A`
- `resolvedA` == `a`.

### Initialize

If a struct has a method `Initialize()`, it will automatically be called immediately after
an instance of the type is created.

```go
func (b *B) Initialize() {
	b.Type = "None"
}
```

### Automatic Resolution

The library can automatically build new structs by recursively walking its children for dependencies it can create.

```go
di.BindAuto[B]()
resolvedB := di.Instance[B]()
```

- Private members are not set by the library, so `resolvedB.privateDep` === nil
- `resolvedB` is a `*B`
- `resolvedB.Type` == "None" from the call to `B.Initialize()`
- `resolvedB.PtrDep` === `a`
- `resolvedB.ValueDep` == `*a`

### BindImpl

You can also bind an interface `I` to an instance that implements it with `BindImpl[I]()`

```go
di.BindImpl[I](resolvedB)
```

### Impl

Note that when resolving an interface, use `Impl[I]()` instead of `Instance[I]()`

```go
resolvedI1 := di.Impl[I]()
```
- `resolvedI` === `resolvedB`

### BindType

We can also bind an interface to a type. Note that we are overwriting our previous binding to `I`.

```go
di.BindType[I, C]()
resolvedI2 := di.Impl[I]()
```

- `di.Impl[I]()` === `di.Instance[C]()`

### BindProvider

`BindProvider(func)` will bind a type to a provider function. The parameters  are `Instanced()`-ed
before being injected to the function. The bound type is the return type of the function.
Providers can be used for things that cannot be automatically resolved, such as private
instance variables.

```go
di.BindProvider(func(injectedA *A) (I, error) {
    return &B{
        privateDep: injectedA,
    }, nil
})

resolvedI3 := di.Impl[I]()
```

- `injectedA` === `resolvedA`
- `di.Impl[I]()` is now generated by the callback we defined.
- The generated struct is only constructed once; the callback is not invoked multiple times.
- `di.Impl[I]()` === `di.Impl[I]()`

### BindFactory

`BindFactory(func)` works the same as `BindProvider(func)` except that it will be invoked
to return a new instance each time it is `Instance()`-ed

```go
di.BindFactory(func() (*A, error) {
    return &A{
        Name: "Created from factory",
    }, nil
})

resolvedA2 := di.Instance[A]()
```

- `di.Instance[A]()` != `di.Instance(A)[]`

### Resolve

If you need to be able to catch errors that occur while resolving a type, you can use
`Resolve[T]()`, instead of `Instance[T]()` which returns the instance along with an `error`.

```go
resolvedA3, err1 := di.Resolve[A]()
```
	
### ResolveImpl

And similarly `ResolveImpl[I]()` can be used in place of `Impl[I]()`.

```go
resolvedI4, err2 := di.ResolveImpl[I]()
```
	
### Invoke 

To inject resolved instances into arbitrary code us Invoke(). Note that the callback can
set values in the outer scope.

```go
var name string

di.Invoke(func(injected A) {
    name = injected.Name
})
```

### SetLogger

You can set a logger.

```go
logger := log.New(os.Stdout, "DI: ", 0)
di.SetLogger(logger)
```

### Reset

You can call `Reset()` to clear all bindings.

```go
di.Reset()
```

## Examples

The examples above are implemented in a valid test here: [example/tothepoint_test.go](example/tothepoint_test.go)

You can see usage within a sample app here: [sample_app/main.go](sample_app/main.go)

See [example/example_test.go](example/example_test.go) to see and run additional examples.

[example/EXAMPLES.md](example/EXAMPLES.md) provides the additional examples in a markdown document.

